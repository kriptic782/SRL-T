(*
GrandExchange
=============
Methods to interact with the grand exchange.
*)
{$DEFINE SRL_GRANDEXCHANGE_INCLUDED}
{$IFNDEF SRL_OSR}
  {$I SRL-T/osr.simba}
{$ENDIF}

type
  ERSGEOverviewButton = (
    CHANGE_TAB,
    COLLECT
  );

  ERSGESetupOfferButton = (
    HISTORY,
    ITEM,
    QUANTITY,
    PRICE,
    QUANTITY_1,
    QUANTITY_10,
    QUANTITY_100,
    QUANTITY_ALL,
    QUANTITY_ENTER,
    PRICE_DECREASE,
    PRICE_GUIDE,
    PRICE_ENTER,
    PRICE_INCREASE,
    TOTAL,
    CONFIRM
  );

  ERSGEOfferStatusButton = (
    HISTORY,
    ITEM,
    QUANTITY,
    PRICE,
    TOTAL,
    PROGRESS
  );

  ERSGEInterface = (
    UNKNOWN,
    OVERVIEW,
    HISTORY,
    OFFER_STATUS,
    OFFER_SETUP
  );

  ERSGEOfferCreateButton = (
    BUY,
    SELL
  );

  TRSGrandExchange = record(TRSTitledInterface)
    FINDER_BANKER: TRSObjectFinder;
    FINDER_CLERK: TRSObjectFinder;
  end;

  ERSGEOfferStatus = (ACTIVE, COMPLETE, ABORTED, EMPTY, UNKNOWN);

function TRSGrandExchange.GetSetupOfferButtons: TRSButtonArray;
begin
  Result := Self.FindButtons([[45,18], [35,25], [152,40],[160,18], [159,18], [210,18], [410,18], [40,36]]);
end;

function TRSGrandExchange.GetSetupOfferButton(Button: ERSGESetupOfferButton): TRSButton;
var
  Buttons: TRSButtonArray := Self.GetSetupOfferButtons();
begin
  if Length(Buttons) = Length(ERSGESetupOfferButton) then
    Result := Buttons[Button];
end;

function TRSGrandExchange.GetOverviewButtons: TRSButtonArray;
begin
  Result := Self.FindButtons([[45,18], [55,18], [81,18]]);
end;

function TRSGrandExchange.GetOverviewButton(Button: ERSGEOverviewButton): TRSButton;
var
  I: Int32;
  Buttons: TRSButtonArray := Self.GetOverviewButtons();
begin
  case Button of
    ERSGEOverviewButton.COLLECT: // Can be hidden
      begin
        for I := 0 to High(Buttons) do
          if Buttons[I].FindText('Collect', RS_FONT_PLAIN_11, $FFFFFF) then
            Exit(Buttons[I]);
      end;
    else
      if Length(Buttons) >= Length(ERSGEOverviewButton) - 1 then
        Result := Buttons[Button];
  end;
end;

function TRSGrandExchange.GetOfferStatusButtons: TRSButtonArray;
begin
  Result := Self.FindButtons([[45,18], [36,32], [40,36],[292,15], [160,18], [159,18], [410,18], [210,18]]);
end;

function TRSGrandExchange.GetOfferStatusButton(Button: ERSGEOfferStatusButton): TRSButton;
var
  Buttons: TRSButtonArray := Self.GetOfferStatusButtons();
begin
  if Length(Buttons) = Length(ERSGEOfferStatusButton) then
    Result := Buttons[Button];
end;

// Finds the BUY and SELL buttons to create an offer within a given slot
function TRSGrandExchange.GetOfferCreateButtons(slotNumber : Int32) : TRSButtonArray;
begin
  result := self.FindButtons([[46,45]], self.GetOfferSlots()[slotNumber]);
end;

function TRSGrandExchange.GetOfferCreateButton(Button : ERSGEOfferCreateButton; slotNumber : Int32) : TRSButton;
var
  Buttons: TRSButtonArray := Self.GetOfferCreateButtons(slotNumber);
begin
  if Length(Buttons) = Length(ERSGEOfferCreateButton) then
    Result := Buttons[Button];
end;

function TRSGrandExchange.FindNPC(Finder: TRSObjectFinder): T2DPointArray;
var
  TPA: TPointArray;
  P: TPoint;
  B: TBox;
  I: Int32;
  Weights: TIntegerArray;
  Size: Int32;
begin
  // Find center G.E using yellow dots
  TPA := Minimap.GetDots(ERSMinimapDot.NPC);
  TPA.Offset([2, 2]);
  TPA := TPA.Cluster(15).Biggest();
  with TPA.MeanEx() do
    P := Minimap.VecToMS([X, Y]);

  // Size of GE center at fixed client & default(50) zoom.
  Size := MainScreen.NormalizeDistance(110);

  // Center G.E on the mainscreen
  B := [P.X, P.Y, P.X, P.Y];
  B := B.Expand(Size);

  Result := MainScreen.FindObject(Finder, B);

  if (Length(Result) > 0) then
  begin
    // Weigh from center AND towards the player
    SetLength(Weights, Length(Result));
    for I := 0 to High(Result) do
      if Length(Result[I]) > 0 then
        Weights[I] := Distance(Result[I].Mean, P) + Min(Distance(Result[I].Mean, MainScreen.Center), Size);

    QuickATPASort(Weights, Result, 0, High(Result), True);
  end;
end;

function TRSGrandExchange.OpenBank: Boolean;
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  P: TPoint;
begin
  if Bank.IsOpen() or Bank.Open(Mouse.Position()) then
    Exit(True);

  ATPA := Self.FindNPC(Self.FINDER_BANKER);
  if Length(ATPA) > 3 then
    SetLength(ATPA, 3);

  for TPA in ATPA do
  begin
    P := TPA[Random(Length(TPA))];
    P.X += Random(-2, 2);
    P.Y += Random(-2, 2);

    if Bank.Open(P) then
      Exit(True);
  end;
end;

function TRSGrandExchange.Open(): Boolean;
var
  ATPA: T2DPointArray;
  TPA: TPointArray;
  P: TPoint;
begin
  if self.IsOpen() then
    Exit(True);

  ATPA := Self.FindNPC(Self.FINDER_CLERK);

  if Length(ATPA) > 2 then
    SetLength(ATPA, 2);

  for TPA in ATPA do
  begin
    P := TPA.Bounds.Middle().Random(0,5);
    Mouse.Move(P);

    if ('Clerk' in MainScreen.GetUpText()) then
      Result := ChooseOption.Select('Exchange Grand');

    if Result then
    begin
      if Minimap.HasFlag(Random(200, 400)) then
        Minimap.WaitFlag();

      if BankPin.IsOpen(2000) then
        BankPin.Enter(Login.GetPlayerPin());

      Result := waitUntil(Self.IsOpen(), 250, 2500);
    end;

    if result then exit();
  end;
end;

function TRSGrandExchange.GetTitleText() : String;
var
  titleBox : tBox;
begin
  titleBox := [Self.X1, Self.Y1, Self.X2, Self.Y1+30];
  result := OCR.Recognize(titleBox, TOCRColorFilter.Create([2070783]), RS_FONT_BOLD_12);
end;

function TRSGrandExchange.GetCurrentInterface: ERSGEInterface;
var
  tabText : String;
begin
  if (Pos('Set up', self.GetTitleText()) > 0) then
    Result := ERSGEInterface.OFFER_SETUP
  else
  if (Pos('status', self.GetTitleText()) > 0) then
    Result := ERSGEInterface.OFFER_STATUS
  else
  if Self.GetOverviewButton(ERSGEOverviewButton.CHANGE_TAB).Visible() then
  begin
    tabText := OCR.Recognize(Self.GetOverviewButton(ERSGEOverviewButton.CHANGE_TAB).Bounds, TOCRColorFilter.Create([2070783, $FFFFFF]), RS_FONT_PLAIN_11);
    if lowercase(tabText) = 'history' then
      Result := ERSGEInterface.OVERVIEW
    else if lowercase(tabText) = 'exchange' then
      Result := ERSGEInterface.HISTORY;
  end;
end;

function TRSGrandExchange.IsOpen: Boolean;
begin
  Result := Self.GetCurrentInterface() <> ERSGEInterface.UNKNOWN;
end;

function TRSGrandExchange.Close(PressEscape: Boolean = False): Boolean;
begin
  if not Self.IsOpen() then
    Exit(True);

  Result := Self.ClickCloseButton(PressEscape) and WaitUntil(not Self.IsOpen(), SRL.TruncatedGauss(50, 1500), Random(1500, 2000));
end;

function TRSGrandExchange.changeTab(toHistory: Boolean = True) : Boolean;
begin
  if (toHistory and (self.getCurrentInterface() = ERSGEInterface.HISTORY)) or
    ((not toHistory) and (self.getCurrentInterface() = ERSGEInterface.OVERVIEW)) then Exit(True);

  self.GetOverviewButton(ERSGEOverviewButton.CHANGE_TAB).Click();

  if toHistory then result := waitUntil(self.GetCurrentInterface() = ERSGEInterface.HISTORY, 250, 2000)
  else result := waitUntil(self.GetCurrentInterface() = ERSGEInterface.OVERVIEW, 250, 2000);

  if not result then
  begin
    Mouse.Click(self.GetOverviewButton(ERSGEOverviewButton.CHANGE_TAB).Bounds.Middle(), MOUSE_LEFT);

    if toHistory then result := waitUntil(self.GetCurrentInterface() = ERSGEInterface.HISTORY, 250, 2000)
    else result := waitUntil(self.GetCurrentInterface() = ERSGEInterface.OVERVIEW, 250, 2000);
  end;
end;

function TRSGrandExchange.FindProgressPopup(out b : tBox) : Boolean;
var
  yellow : tPointArray;
  toolTips : t2DPointArray;
begin
  if SRL.FindColors(Yellow, CTS1(10551295, 0), self.Bounds()) then
  begin
    toolTips := yellow.Cluster(1);
    toolTips.SortByDensity(False);

    if (length(toolTips) = 0) or (length(toolTips[0]) < 500) then exit();

    b := toolTips[0].bounds();
    result := True;
  end;
end;

function TRSGrandExchange.FindProgressPopup() : Boolean; overload;
var b : tBox;
begin
  result := self.FindProgressPopup(b);
end;

procedure TRSGrandExchange.MouseOffSlots();
begin
  Mouse.Move(self.Bounds().Expand(5).NearestEdge(Mouse.Position()));
end;

function TRSGrandExchange.GetItemName: String;
var
  Button: TRSButton;
  B: TBox;
begin
  B.X1 := Self.X1 + 175;
  B.Y1 := Self.Y1 + 45;
  B.X2 := Self.X2 - 25;
  B.Y2 := Self.Y1 + 65;

  case Self.GetCurrentInterface() of
    ERSGEInterface.OFFER_SETUP:  Result := OCR.Recognize(B, TOCRColorFilter.Create([2070783]), RS_FONT_BOLD_12);
    ERSGEInterface.OFFER_STATUS: Result := OCR.Recognize(B, TOCRColorFilter.Create([2070783]), RS_FONT_BOLD_12);
  end;
end;

function TRSGrandExchange.GetItemQuantity: Int32;
var
  Button: TRSButton;
begin
  case Self.GetCurrentInterface() of
    ERSGEInterface.OFFER_SETUP:  Button := Self.GetSetupOfferButton(ERSGESetupOfferButton.QUANTITY);
    ERSGEInterface.OFFER_STATUS: Button := Self.GetOfferStatusButton(ERSGEOfferStatusButton.QUANTITY);
  end;

  if Button.Visible() then
    Result := OCR.RecognizeNumber(Button.Bounds, TOCRColorFilter.Create([4176127]), RS_FONT_PLAIN_11);
end;

function TRSGrandExchange.GetItemPrice: Int32;
var
  Button: TRSButton;
begin
  case Self.GetCurrentInterface() of
    ERSGEInterface.OFFER_SETUP:  Button := Self.GetSetupOfferButton(ERSGESetupOfferButton.PRICE);
    ERSGEInterface.OFFER_STATUS: Button := Self.GetOfferStatusButton(ERSGEOfferStatusButton.PRICE);
  end;

  if Button.Visible() then
    Result := OCR.RecognizeNumber(Button.Bounds,  TOCRColorFilter.Create([4176127]), RS_FONT_PLAIN_11);
end;

function TRSGrandExchange.GetItemTotalPrice: Int32;
var
  Button: TRSButton;
begin
  case Self.GetCurrentInterface() of
    ERSGEInterface.OFFER_SETUP:  Button := Self.GetSetupOfferButton(ERSGESetupOfferButton.TOTAL);
    ERSGEInterface.OFFER_STATUS: Button := Self.GetOfferStatusButton(ERSGEOfferStatusButton.TOTAL);
  end;

  if Button.Visible() then
    Result := OCR.RecognizeNumber(Button.Bounds,  TOCRColorFilter.Create([$FFFFFF]), RS_FONT_PLAIN_12);
end;

function TRSGrandExchange.GetItemGuidePrice: Int32;
var
  Button: TRSButton;
  B: TBox;
begin
  case Self.GetCurrentInterface() of
    ERSGEInterface.OFFER_SETUP:  Button := Self.GetSetupOfferButton(ERSGESetupOfferButton.ITEM);
    ERSGEInterface.OFFER_STATUS: Button := Self.GetOfferStatusButton(ERSGEOfferStatusButton.ITEM);
  end;

  if Button.Visible() then
  begin
    B := Button.Bounds;
    B.Y1 += 40;
    B.Y2 += 20;
    B.X2 += 40;

    Result := OCR.RecognizeNumber(B,  TOCRColorFilter.Create([4176127]), RS_FONT_PLAIN_11);
  end;
end;

function TRSGrandExchange.IsSearchOpen: Boolean;
begin
  Result := OCR.LocateText(Chat.Bounds, 'What would you like to buy', RS_FONT_BOLD_12, TOCRColorFilter.Create([$000000]), 1);
end;

function TRSGrandExchange.OpenSearch: Boolean;
begin
  if Self.IsSearchOpen() then
    Exit(True);

  if Self.GetSetupOfferButton(ERSGESetupOfferButton.item).Click() then
    Result := WaitUntil(Self.IsSearchOpen(), 500, 2500);
end;

function TRSGrandExchange.GetCurrentSearch: String;
begin
  Result := OCR.Recognize(Chat.Bounds,  TOCRColorFilter.Create([8388608]), RS_FONT_BOLD_12).StripR('*');
end;

function TRSGrandExchange.GetPreviousSearch: String;
var
  B : tBox;
begin
  // Offset from chat to find the result box
  B := [chat.x1 + 254, chat.y1 + 28, chat.x2 - 138, chat.y2 - 80];
  result := OCR.RecognizeLines(B, TOCRColorFilter.Create([$000000]), RS_FONT_PLAIN_12).Merge(' ');
end;

function TRSGrandExchange.ClearSearch: Boolean;
begin
  while (Self.GetCurrentSearch() <> '') do
    Keyboard.PressKey(VK_BACK);

  Result := Self.IsOpen() and (Self.GetCurrentSearch() = '');
end;

function TRSGrandExchange.FindSearch(Item: String; out B: TBox): Boolean;
var
  searchGrid : tBoxArray := grid(3,3, 161, 32, point(0,0), point(Chat.X1 + 11, Chat.Y1 + 29));
begin
  if (Item <> '') then
    Item[1] := UpCase(Item[1]);

  for b in searchGrid do
    if OCR.RecognizeLines(b, TOCRColorFilter.Create([$000000]), RS_FONT_PLAIN_12).Merge(' ') = Item then
    begin
      result := True;
      break;
    end;
end;

function TRSGrandExchange.ClickSearch(Item: String): Boolean;
var
  B: TBox;
begin
  Result := Self.IsSearchOpen() and (OCR.LocateText(Chat.Bounds, Item, RS_FONT_PLAIN_12,  TOCRColorFilter.Create([$000000]), B) = 1);
  if Result then
    Mouse.Click(B, MOUSE_LEFT);
end;

function TRSGrandExchange.Search(Item: String; Click: Boolean): Boolean;
var
  B: TBox;
begin
  if OCR.LocateText(Chat.Bounds, Item, RS_FONT_BOLD_12, TOCRColorFilter.Create([8388608]), 1) then
    Exit(True);

  if Self.OpenSearch() and Self.ClearSearch() then
  begin
    if self.GetPreviousSearch = Item then
    begin
      B := [chat.x1 + 124, chat.y1 + 28, chat.x2 - 138, chat.y2 - 80];

      result := True;
    end else
    begin
      Keyboard.Send(Item);

      Result := WaitUntil(Self.FindSearch(Item, B), 500, 2500);
    end;

    if Result and Click then
      Mouse.Click(B, MOUSE_LEFT);
  end;
end;

type
  ERSGEOfferType = (EMPTY, BUY, SELL, UNKNOWN);

  TRSGEOfferStatus = record
    OfferType: ERSGEOfferType;
    Item: String;
    Quantity: Int32;
    PricePerItem: Int32;
    TotalPrice: Int32;
    Progress: Int32;
  end;

function TRSGrandExchange.ReturnToMain() : Boolean;

  // Finder for the back arrow
  function findArrow() : tBox;
  var
    TPA : tPointArray;
    ATPA : T2DPointArray;
    arrowColor : TCTS2Color;
    B : tBox;
    W, H : Int32;
  begin
    arrowColor := CTS2(10791348, 18, 0.11, 0.22);
    SRL.FindColors(TPA, arrowColor, Self.Bounds());

    if length(TPA) = 0 then Exit();

    ATPA := TPA.Cluster(1);

    for TPA in ATPA do
    begin
      B := TPA.Bounds();
      B.GetDimensions(W, H);

      if inRange(W, 20, 30) and inRange(H, 10, 20) then
        exit(B);
    end;
  end;

begin
  if self.GetCurrentInterface() = ERSGEInterface.OVERVIEW then exit(True);

  Mouse.Click(findArrow().Middle().Random(0,3), MOUSE_LEFT);
  Result := waitUntil(self.GetCurrentInterface() = ERSGEInterface.OVERVIEW, 200, 2000);
  if Result then wait(800,1200); // Previously was returning too quickly and allowing GE lag to interrupt the next functions
end;

function TRSGrandExchange.nextEmptySlot() : Int32;

  function GetStatus() : array of ERSGEOfferType;
  var i : Int32;
  begin
    setLength(result, 8);
    for i := 0 to 7 do
      result[i] := self.GetOfferStatus(i).OfferType;
  end;

var
  i : Integer;
  status : array of ERSGEOfferType;
begin
  status := GetStatus();

  for i := 0 to 7 do
  begin
    if (status[i] = ERSGEOfferType.UNKNOWN) and self.FindProgressPopup() then
    begin
      self.MouseOffSlots();
      i := 0;
      status := GetStatus();
      continue();
    end;
    if status[i] = ERSGEOfferType.EMPTY then
      exit(i);
  end;

  // Fail to -1
  exit(-1);
end;

function TRSGrandExchange.readCash() : Int32;
begin
  // Due to flashing inventory, count stack can fail - this tries several times
  waitUntil((result := Inventory.CountItemStack('Coins')) > 0, 400, 2000);
end;

function TRSGrandExchange.GetOfferSlots: TBoxArray;
begin
  Result := Grid(4, 2, 114, 109, [3, 11], [Self.X1 + 9, Self.Y1 + 64]);
end;

function TRSGrandExchange.GetProgress(B: TBox; BarSize: Int32): Int32;
var
  TPA: TPointArray;
begin
  if SRL.FindColors(TPA, [1664168, 18944], B) then
    Result := Round(TPA.Bounds.Width() / BarSize * 100)
  else
  if SRL.CountColor(111, B) > BarSize then
    Result := -1;
end;

function TRSGrandExchange.GetProgress(slotNumber : Int32) : Int32; overload;
begin
  result := self.GetProgress(self.GetOfferSlots()[slotNumber], 105);
end;

function TRSGrandExchange.GetPreciseProgress(slotNumber : Int32) : Integer;
var
  slotBox, progressBox : tBox;
  progressText : tStringArray;
begin
  slotBox := self.GetOfferSlots()[slotNumber];
  if (not self.FindProgressPopup(progressBox)) and pointInBox(Mouse.Position(), slotBox) then
  begin
    self.MouseOffSlots();
    wait(random(250,400));
  end;

  if not pointInBox(Mouse.Position(), self.GetOfferSlots()[slotNumber]) then
  begin
    Mouse.Move(self.GetOfferSlots()[slotNumber]);
    waitUntil(self.FindProgressPopup(progressBox), 250, 2000);
  end;

  progressText := OCR.RecognizeLines(progressBox, TOCRColorFilter.Create([$000000]), RS_FONT_PLAIN_12);
  if length(progressText) < 2 then exit(-1);

  result := progressText[1].Before('/').ExtractNumber(-1);
end;

function TRSGrandExchange.GetOfferStatus(Slot: Int32): TRSGEOfferStatus;
var
  Slots: TBoxArray;
begin
  Slots := Self.GetOfferSlots();

  case OCR.Recognize(Slots[Slot], TOCRColorFilter.Create([2070783]), RS_FONT_BOLD_12) of
    'Empty': Result.OfferType := ERSGEOfferType.EMPTY;
    'Buy':   Result.OfferType := ERSGEOfferType.BUY;
    'Sell':  Result.OfferType := ERSGEOfferType.SELL;
    else     Result.OfferType := ERSGEOfferType.UNKNOWN;
  end;

  if (Result.OfferType <> ERSGEOfferType.EMPTY) then
  begin
    Result.Item := OCR.RecognizeLines(Slots[Slot], TOCRColorFilter.Create([4176127]), RS_FONT_PLAIN_11).Merge(' ');
    Result.PricePerItem := OCR.RecognizeNumber(Slots[Slot], TOCRColorFilter.Create([2070783]), RS_FONT_PLAIN_11);
    Result.Quantity := SRL.GetItemAmount(Slots[Slot]);
    Result.TotalPrice := Result.Quantity * Result.PricePerItem;
    Result.Progress := Self.GetProgress(Slots[Slot], 105);
  end;
end;

function TRSGrandExchange.IsSlotComplete(slotNumber: Int32): Boolean;
begin
  result := SRL.CountColor(18944, self.GetOfferSlots()[slotNumber]) > 0;
end;

function TRSGrandExchange.GetStatus(slotNumber : Int32; out status : TRSGEOfferStatus) : ERSGEOfferStatus;
begin
  if Self.GetCurrentInterface() = ERSGEInterface.OFFER_STATUS then exit(self.GetStatus());

  Status := self.GetofferStatus(slotNumber);

  if (Status.OfferType = ERSGEOfferType.UNKNOWN) then
  begin
    self.MouseOffSlots();
    waitUntil(not self.FindProgressPopup(), 500, 2000);
    wait(Random(250,600));
    Status := self.GetofferStatus(slotNumber);
  end;

  if Status.OfferType = ERSGEOfferType.EMPTY then exit(ERSGEOfferStatus.EMPTY);
  if Status.OfferType = ERSGEOfferType.UNKNOWN then exit(ERSGEOfferStatus.UNKNOWN);

  if (Status.Progress = -1) then exit(ERSGEOfferStatus.ABORTED);
  if (Status.Progress = 100) and self.IsSlotComplete(slotNumber) then exit(ERSGEOfferStatus.COMPLETE);

  result := ERSGEOfferStatus.ACTIVE;
end;

function TRSGrandExchange.GetStatus(slotNumber : Int32) : ERSGEOfferStatus; overload
var Status : TRSGEOfferStatus;
begin
  if Self.GetCurrentInterface() = ERSGEInterface.OFFER_STATUS then exit(self.GetStatus());

  result := self.GetStatus(slotNumber, status);
end;

// Get the status from the OFFER_STATUS interface
function TRSGrandExchange.GetStatus() : ERSGEOfferStatus ; overload;
begin
  if (self.GetCurrentInterface() <> ERSGEInterface.OFFER_STATUS) then
  begin
    self.DebugLn('WARNING: You must specify a slot number OR be on the OFFER_STATUS screen');
    exit(ERSGEOfferStatus.UNKNOWN);
  end;

  if SRL.CountColor(143, self.GetOfferStatusButton(ERSGEOfferStatusButton.PROGRESS).Bounds) > 0 then
    exit(ERSGEOfferStatus.ABORTED);

  if SRL.CountColor(24320, self.GetOfferStatusButton(ERSGEOfferStatusButton.PROGRESS).Bounds) > 0 then
    exit(ERSGEOfferStatus.COMPLETE);

  result := ERSGEOfferStatus.ACTIVE;
end;

function TRSGrandExchange._EnterQuantity(quantity : Int32) : Boolean;
var
  button : ERSGESetupOfferButton;
  currentQuantity : Int32;
begin
  currentQuantity := Self.GetItemQuantity();
  if currentQuantity = quantity then
    Exit(True);

  case quantity of
    1:        button := ERSGESetupOfferButton.QUANTITY_1;
    10:       button := ERSGESetupOfferButton.QUANTITY_10;
    100:      button := ERSGESetupOfferButton.QUANTITY_100;
    1000, -1: button := ERSGESetupOfferButton.QUANTITY_ALL;
    else      button := ERSGESetupOfferButton.QUANTITY_ENTER;
  end;

  if Self.GetSetupOfferButton(button).Click() then
    if button = ERSGESetupOfferButton.QUANTITY_ENTER then
    begin
      if waitUntil(OCR.Recognize(Chat.Bounds,  TOCRColorFilter.Create([$000000]), RS_FONT_BOLD_12) = 'How many do you wish to buy?', 250, 4000) then
      begin
        wait(random(400,800));
        KeyBoard.Send(toStr(quantity), VK_ENTER);
      end;
    end;

  if quantity > -1 then
    Result := waitUntil((Self.GetItemQuantity() = quantity), 200, 2000)
  else
    Result := waitUntil((Self.GetItemQuantity() > 0), 200, 2000);
end;

procedure TRSGrandExchange._EnterPrice(price : String);

  // Allows the user to specify "+10" and the PRICE_INCREASE button will be pressed twice
  function calculateClicks(price : String; out button : ERSGESetupOfferButton) : Int32;
  var
    priceChange : Int32;
  begin
    if not ((price[1] = '+') or (price[1] = '-')) then
    begin
      button := ERSGESetupOfferButton.PRICE_ENTER;
      exit(1);
    end;

    // Strip the + or - off the number
    priceChange := strtoInt(copy(price, 2, length(price)));
    if priceChange mod 5 <> 0 then
    begin
      self.DebugLn('WARNING: You cannot pass a price change that is not a multiple of 5');
      exit(0);
    end;

    if price[1] = '+' then button := ERSGESetupOfferButton.PRICE_INCREASE
    else button := ERSGESetupOfferButton.PRICE_DECREASE;

    exit(round(priceChange/5));
  end;

var
  button : ERSGESetupOfferButton;
  buttonClicks, i: Int32;
begin
  case lowercase(price) of
    'mid', 'market', '-1': button := ERSGESetupOfferButton.PRICE_GUIDE;
    else buttonClicks := calculateClicks(price, button);
  end;

  // For now I can't think of any action required for guide price because it's automatically filled
  if button = ERSGESetupOfferButton.PRICE_GUIDE then Exit();

  for i := 1 to buttonClicks do
  begin
    if self.GetSetupOfferButton(button).Click() then
    begin
      wait(random(200,400));
      if button = ERSGESetupOfferButton.PRICE_ENTER then
      begin
        if waitUntil(OCR.Recognize(Chat.Bounds,  TOCRColorFilter.Create([$000000]), RS_FONT_BOLD_12) = 'Set a price for each item:', 250, 4000) then
        begin
          wait(random(400,800));
          KeyBoard.Send(toStr(price), VK_ENTER);
        end;
      end;
    end;
  end;
end;

function TRSGrandExchange._clickConfirm() : Boolean;
begin
  if not waitUntil((self.GetCurrentInterface = ERSGEInterface.OFFER_SETUP), 250, 2000) then
    exit();

  result := waitUntil(Self.GetSetupOfferButton(ERSGESetupOfferButton.CONFIRM).Click(), 150, 1000);

  if result then
    result := waitUntil((self.GetCurrentInterface = ERSGEInterface.OVERVIEW), 250, 2000);
end;

function TRSGrandExchange.CreateBuyOffer(itemName : String; price : String = '-1'; quantity: Int32 = 1; slotNumber : Int32 = -1) : Boolean;
begin
  if not self.IsOpen() then Exit(False);

  if slotNumber = -1 then
    slotNumber := self.NextEmptySlot();

  if slotNumber = -1 then
  begin
    self.DebugLn('TRSGrandExchange.createBuyOffer: No empty slots');
    exit(False);
  end;

  if not Self.GetOfferCreateButton(ERSGEOfferCreateButton.BUY, slotNumber).Visible() and self.FindProgressPopup() then
  begin
    self.MouseOffSlots();
    waitUntil(Self.GetOfferCreateButton(ERSGEOfferCreateButton.BUY, slotNumber).Visible(), 100, 1000);
  end;

  if not Self.GetOfferCreateButton(ERSGEOfferCreateButton.BUY, slotNumber).Click() then
  begin
    self.DebugLn('TRSGrandExchange.createBuyOffer: Failed to click buy button');
    exit(False);
  end;

  WaitUntil(Self.IsSearchOpen(), 500, 2500);

  wait(random(400,800));

  if not Self.Search(itemName, True) then
  begin
    self.DebugLn('TRSGrandExchange.createBuyOffer: Searching for ' + itemName + ' failed');
    exit(False);
  end;

  waitUntil((self.GetItemQuantity > 0), 250, 2000);

  if Self._EnterQuantity(quantity) then
  begin
    Self._EnterPrice(price);

    wait(random(400,800));

    if self._clickConfirm() then
      result := waitUntil(self.GetStatus(slotNumber) = ERSGEOfferStatus.ACTIVE, 250, 4000)
    else
    begin
      self.DebugLn('TRSGrandExchange.createBuyOffer: Failed to click confirm button');
      exit(False);
    end;
  end else
  begin
    self.DebugLn('TRSGrandExchange.createBuyOffer: Could not enter Quantity properly');
    exit(False);
  end;
end;

// Enter -1 for ALL
function TRSGrandExchange.CreateSellOffer(invSlot : Int32; price : String = '-1'; quantity: Int32 = -1; slotNumber : Int32 = -1; uptextCheck: String = '') : Boolean;
begin
  if not self.IsOpen() then Exit(False);

  if slotNumber > -1 then
  begin
    if (not Self.GetOfferCreateButton(ERSGEOfferCreateButton.SELL, slotNumber).Visible()) and self.FindProgressPopup() then
    begin
      self.MouseOffSlots();
      waitUntil(Self.GetOfferCreateButton(ERSGEOfferCreateButton.SELL, slotNumber).Visible(), 100, 1000);
    end;

    if not Self.GetOfferCreateButton(ERSGEOfferCreateButton.SELL, slotNumber).Click() then
    begin
      self.DebugLn('TRSGrandExchange.createSellOffer: Failed to click sell button');
      exit(False);
    end;

    if not waitUntil((self.GetCurrentInterface = ERSGEInterface.OFFER_SETUP), 250, 2000) then
    begin
      self.DebugLn('TRSGrandExchange.createSellOffer: Failed to open interface by clicking button');
      exit(False);
    end;
  end else
    slotNumber := self.NextEmptySlot(); // For checking result at the end only

  if not Inventory.IsSlotUsed(invSlot) then
  begin
    self.DebugLn('TRSGrandExchange.createSellOffer: Nothing exists in inventory slot ' + toStr(InvSlot));
    exit(False);
  end;

  Inventory.ClickSlot(invSlot);

  if ChooseOption.IsOpen(600) then
    ChooseOption.Select('Exchange');

  if not waitUntil((self.GetItemQuantity > 0), 250, 2000) then
  begin
    self.DebugLn('TRSGrandExchange.createSellOffer: Offer quantity did not show up');
    exit(False);
  end;

  if uptextCheck <> '' then
  begin
    if not (stringMatch(LowerCase(uptextCheck), LowerCase(self.GetItemName())) > 0.8) then
    begin
      self.DebugLn('TRSGrandExchange.createSellOffer: Incorrect item name, detected "' + self.GetItemName() + '"');
      exit(False);
    end;
  end;

  if quantity <> 0 then
    if ((quantity = -1) or (self.GetItemQuantity < quantity))then
      Self._EnterQuantity(quantity);

  Self._EnterPrice(price);

  wait(random(400,800));

  if self._clickConfirm() then
    result := waitUntil(self.GetStatus(slotNumber) = ERSGEOfferStatus.ACTIVE, 250, 4000);
end;

function TRSGrandExchange.CreateSellOffer(itemName : String; price : String = '-1'; quantity: Int32 = -1; slotNumber : Int32 = -1) : Boolean; overload;
var
  invSlot : Int32;
  item : String;
begin
  item := itemName;

  if (System.ItemFinder.ItemNames.IndexOfName('noted ' + itemName) > -1) and Inventory.FindItem('noted ' + itemName, invSlot) then
    item := 'noted ' + itemName
  else
    if not Inventory.FindItem(item, InvSlot) then
    begin
      self.DebugLn('TRSGrandExchange.createSellOffer: Cannot find ' + itemName);
      exit(False);
    end;

  result := self.CreateSellOffer(invSlot, price, quantity, slotNumber, itemName);
end;

function TRSGrandExchange.OpenActiveOffer(slotNumber: Int32) : Boolean;
begin
  if (self.GetCurrentInterface() = ERSGEInterface.OFFER_STATUS) then exit(True);
  if (self.GetStatus(slotNumber) = ERSGEOfferStatus.EMPTY) then exit(False); // Cannot open an empty slot

  Mouse.Click(self.GetOfferSlots()[slotNumber], MOUSE_LEFT);
  result := waitUntil((self.GetCurrentInterface() = ERSGEInterface.OFFER_STATUS), 400, 2000);

  // Additional lag after the slot opens before the info loads
  if result then waitUntil(SRL.CountColor(RS_ITEM_BORDER, Self.GetOfferStatusButton(ERSGEOfferStatusButton.item).Bounds) > 0, 250, 4000);
end;

function TRSGrandExchange.GetCollectionBoxes() : tBoxArray;
begin
  result := grid(2, 1, 36, 33, point(15,0), point(self.X2 - 105, self.Y2 - 52));
end;

function TRSGrandExchange.CountCollectionSlots() : Int32;
var slot : Int32;
begin
  result := 0;
  for slot := 0 to 1 do
    if SRL.CountColor(RS_ITEM_BORDER, self.GetCollectionBoxes()[slot]) then Result += 1;
end;

function TRSGrandExchange.CollectOffer() : Boolean;
var tries : Int32;
begin
  if not (self.GetCurrentInterface() = ERSGEInterface.OVERVIEW) then
  begin
    self.DebugLn('CollectOffer: You must specify a slot number or be at the overview screen');
    exit(False);
  end;

  for tries := 0 to 2 do
  begin
    if not Self.GetOverviewButton(ERSGEOverviewButton.COLLECT).Visible() then exit(True);

    Self.GetOverviewButton(ERSGEOverviewButton.COLLECT).Click();

    result := waitUntil(not Self.GetOverviewButton(ERSGEOverviewButton.COLLECT).Visible(), 250, 4000);
    if result then exit();
  end;
end;

function TRSGrandExchange.CollectOffer(slotNumber : Int32) : Boolean; overload;

  function collectSlot(b: tBox) : Boolean;
  var
    t : Int64;
  begin
    t := getSystemTime() + 4000;
    while t > getSystemTime() do
    begin
      Mouse.Click(b, MOUSE_LEFT, True);
      if result := waitUntil((SRL.CountColor(RS_ITEM_BORDER, b) = 0), 200, 2000) then exit();
    end;
  end;

var
  cBoxes : TBoxArray;
  collectionBox : tBox;
begin
  if (slotNumber < 0) or (slotNumber > 7) then
  begin
    self.DebugLn('CollectOffer: You must specify a slot between 0 and 7');
    exit(False);
  end;

  if not (self.GetCurrentInterface() = ERSGEInterface.OFFER_STATUS) then
  begin
    if not self.OpenActiveOffer(slotNumber) then
    begin
      self.DebugLn('CollectOffer: Could not open the offer for slot ' + toStr(slotNumber));
      exit(False);
    end;
  end;

  // Interface buttons can't locate the collection boxes easily within this interface
  cBoxes := self.GetCollectionBoxes();

  //writeln('Trying to collect from collection boxes');
  for collectionBox in cBoxes do
    if SRL.CountColor(RS_ITEM_BORDER, CollectionBox) > 0 then
    begin
      if not collectSlot(CollectionBox) then
        self.DebugLn('CollectOffer: Failed to collect from collection box');
    end;

  result := waitUntil(self.GetCurrentInterface() = ERSGEInterface.OVERVIEW, 200, 2000);
end;

function TRSGrandExchange.AbortOffer(slotNumber : Int32) : Boolean;

  // Regular TRSButton does not allow CTS2 or circular buttons
  // This is customized based on FindButtons but for this specific circle
  function findAbortButton() : tBox;
  var
    TPA : tPointArray;
    ATPA : T2DPointArray;
    abortColor : TCTS2Color;
    B : tBox;
    W, H : Int32;
  begin
    abortColor := CTS2(917519, 3, 6.48, 2.52);
    SRL.FindColors(TPA, AbortColor, Self.Bounds());

    if length(TPA) = 0 then Exit();

    ATPA := TPA.Cluster(1);
    for TPA in ATPA do
    begin
      if Length(TPA) > 75 then
        Continue;

      B := TPA.Bounds();
      B.GetDimensions(W, H);

      if (W = 20) and (H = 20) then
        exit(B);
    end;
  end;

var itemCount : Int32;
status: ERSGEOfferStatus;
begin
  status := self.GetStatus(slotnumber);
  if (status = ERSGEOfferStatus.EMPTY) or (status = ERSGEOfferStatus.COMPLETE) then
  begin
    self.DebugLn('AbortOffer: Slot ' + toStr(slotNumber) + ' cannot be aborted, status: ' + toStr(Status));
    exit(False);
  end;

  if (status = ERSGEOfferStatus.ABORTED) then
  begin
    self.DebugLn('AbortOffer: Slot ' + toStr(slotNumber) + ' is already aborted');
    exit(true);
  end;

  if (self.GetCurrentInterface() <> ERSGEInterface.OFFER_STATUS) then
    if not self.OpenActiveOffer(slotNumber) then exit(False);

  // Failsafe in case the status wasn't read correctly above
  if SRL.CountColor(143, self.GetOfferStatusButton(ERSGEOfferStatusButton.PROGRESS).Bounds) > 0 then
  begin
    self.DebugLn('AbortOffer: Slot ' + toStr(slotNumber) + ' is already aborted');
    exit(true);
  end;

  itemCount := self.CountCollectionSlots();
  Mouse.Click(FindAbortButton().Middle().Random(1,4), MOUSE_LEFT);
  Result := waitUntil(self.GetStatus() = ERSGEOfferStatus.ABORTED, 200, 2000);

  if Result then waitUntil((self.CountCollectionSlots() > itemCount), 250, 2000);
    self.DebugLn('GrandExchange: Abort Slot ' + toStr(slotNumber) + ': ' + toStr(result));
end;

function TRSGrandExchange.CreateBuyOffer(itemName : String; price : String = '-1'; quantity: Int32 = 1; slotNumber : Int32 = -1; loops : Int32) : Boolean; overload;
var
  i: Int32;
begin
  if slotNumber = -1 then
    slotNumber := self.NextEmptySlot();

  if slotNumber = -1 then
  begin
    self.DebugLn('TRSGrandExchange.createBuyOffer: No empty slots');
    exit(False);
  end;

  for i := 1 to loops do
  begin
    if self.CreateBuyOffer(itemName, price, quantity, slotNumber) then exit(True);

    self.ReturnToMain();
    waitUntil(self.GetStatus(slotNumber) <> ERSGEOfferStatus.EMPTY, 250, 2500);

    if self.GetStatus(slotNumber) = ERSGEOfferStatus.COMPLETE then exit(true);

    if self.GetStatus(slotNumber) = ERSGEOfferStatus.ABORTED then
    begin
      self.collectOffer(slotNumber);
      if waitUntil(self.GetStatus(slotNumber) = ERSGEOfferStatus.EMPTY, 250, 2500) then continue
      else
      begin
        self.DebugLn('TRSGrandExchange.createBuyOffer: Offer was aborted on init');
        exit(False);
      end;
    end;
  end;
end;

function tRSGrandExchange.CreateSellOffer(invSlot : Int32; price : String = '-1'; quantity: Int32 = -1; slotNumber : Int32 = -1; uptextCheck: String = ''; loops : Int32) : Boolean; overload;
var internalSlotNumber : Int32;
begin
  if slotNumber = -1 then internalSlotNumber := self.NextEmptySlot() else internalSlotNumber := slotNumber;
  for 1 to loops do
  begin
    if self.CreateSellOffer(invSlot, price, quantity, slotNumber, uptextCheck) then exit(True);

    self.ReturnToMain();
    waitUntil(self.GetStatus(internalSlotNumber) <> ERSGEOfferStatus.EMPTY, 250, 2500);

    if self.GetStatus(internalSlotNumber) = ERSGEOfferStatus.COMPLETE then exit(true);

    if self.GetStatus(internalSlotNumber) = ERSGEOfferStatus.ABORTED then
    begin
      self.collectOffer(internalSlotNumber);
      if waitUntil(self.GetStatus(internalSlotNumber) = ERSGEOfferStatus.EMPTY, 250, 2500) then continue
      else
      begin
        self.DebugLn('TRSGrandExchange.CreateSellOffer: Offer was aborted on init');
        exit(False);
      end;
    end;
  end;
end;

type
  TRSGEHistoryItem = record
    OfferType: String;
    Item: String;
    Quantity: Int32;
    PricePerItem: Int32;
    TotalPrice: Int32;
    PreTax: Int32;
    Bounds: TBox;
  end;
  TRSGEHistory = array of TRSGEHistoryItem;

function TRSGrandExchange.GetHistory: TRSGEHistory;
const
  BG_DARK := CTS1(3621708, 5);
  BG_LIGHT := CTS1(4016466, 6);
var
  RowDark, RowLight: TPointArray;
  Row: TBox;
  Rows, Columns: TBoxArray;
  Item: TRSGEHistoryItem;
  tempOfferType : String;
begin
  SRL.FindColors(RowDark, BG_DARK, Self.Bounds);
  SRL.FindColors(RowLight, BG_LIGHT, Self.Bounds);

  Rows := RowDark.Cluster(1).ToTBA() + RowLight.Cluster(1).ToTBA();
  Rows.SortByY();

  for Row in Rows do
  begin
    if (Row.Width < 350) or (Row.Height < 35) then
      Continue;

    Columns := Row.Partition(1, 4);

    // The item icon column (2) is much smaller than 25% and the price information (3) is wider than 25%
    Columns[3].X1 -= 25;
    Columns[2].X2 := Columns[3].X1;

    Item := [];
    Item.Bounds := Row;

    Item.Item := OCR.Recognize(Columns[1].Expand(25, 0), TOCRColorFilter.Create([4176127, $FFFFFF]), RS_FONT_PLAIN_12);
    if (Item.Item = '') then
      Continue;

    tempOfferType := replace(OCR.Recognize(Columns[0], TOCRColorFilter.Create([2070783]), RS_FONT_PLAIN_11), ':', '', [rfReplaceAll]);

    if stringMatch(trim(lowercase(tempOfferType)), 'sold') >= 0.75 then
      Item.OfferType := 'Sell'
    else if StringMatch(trim(lowercase(tempOfferType)), 'bought') > 0.75 then
      Item.OfferType := 'Buy'
    else
      Item.OfferType := '';

    Item.Quantity := SRL.GetItemAmount(Columns[2]);
    if (Item.Quantity = 0) Then
      Item.Quantity := 1;

    Item.TotalPrice := OCR.RecognizeNumber(Columns[3], TOCRColorFilter.Create([4176127]), RS_FONT_PLAIN_11);
    Item.PreTax     := StrToInt(ExtractFromStr('0' + OCR.Recognize(Columns[3], TOCRColorFilter.Create([10461087]), RS_FONT_PLAIN_11).Before(' - '), Numbers));
    Item.PricePerItem := Item.TotalPrice div Item.Quantity;

    Result := Result + Item;
  end;
end;

function TRSGrandExchange.GetHistory(rows: Int32): TRSGEHistory; overload;
var
  pages : Int32;
  forceMove : Boolean;
begin
  if rows > 30 then
    self.DebugLn('GetHistory: WARNING: Reading more than 30 lines at once is prone to duplicates');

  if rows <= 5 then // If only the first 5 (or less) are wanted
  begin
    result := self.GetHistory();

    if length(result) > rows then
      delete(result, rows, length(result) - rows); // Delete extra rows

    exit();
  end;

  while length(result) < rows do
  begin
    result += self.GetHistory();
    if length(result) >= rows then break();

    forceMove := length(result) <= 5; // Only force the mouse to move to the bounds on the first scroll
    Mouse.Move(result[0].Bounds, forceMove);
    Mouse.Scroll(5, True);

    wait(400);
  end;

  if rows > 5 then // if scrolling was involved, scroll back up
    Mouse.Scroll(rows + 3, False);

  if length(result) > rows then
      delete(result, rows, length(result) - rows); // Delete extra rows
end;

function TRSGEHistoryItem.equals(cmp : TRSGEHistoryItem) : Boolean;
begin
  result := True;

  if stringMatch(self.Item, cmp.Item) < 0.75 then exit(False);
  if self.OfferType <> cmp.OfferType then exit(False);
  if self.Quantity <> cmp.Quantity then exit(False);
  if self.TotalPrice <> cmp.TotalPrice then exit(False);
  if self.PricePerItem <> cmp.PricePerItem then exit(False);
end;

function TRSGrandExchange.SearchHistory(search : TRSGEHistoryItem; history: TRSGEHistory = []) : Int32;
var
  i : Int32;
begin
  if length(history) = 0 then history := self.GetHistory(30);

  for i := 0 to high(history) do
    if search.equals(history[i]) then exit(i);

  result := -1; // -1 if no match is found
end;

procedure TRSGrandExchange.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen() then
    Exit;

  Bitmap.DrawButtons(Self.GetSetupOfferButtons);

  inherited;
end;

procedure TRSGrandExchange.Setup; override;
begin
  inherited;

  Self.Name := 'Grand Exchange';
  Self.ButtonColors += [CTS1(2240055, 0), CTS1(2897729, 2), CTS1(2240055, 0), CTS1(2642530, 20), CTS1(3951189, 10), CTS1(2306104, 0)];

  Self.FINDER_BANKER.ColorClusters += [CTS2(6710894, 12, 0.19, 0.07), CTS2(2110788, 11, 0.29, 0.84), 10]; // grey, brown
  Self.FINDER_BANKER.ClusterDistance := 3;
  Self.FINDER_BANKER.Grow := 3;
  Self.FINDER_BANKER.Erode := 3;
  Self.FINDER_BANKER.MinLongSide := 10;

  Self.FINDER_CLERK.Colors += [CTS2(6176331, 11, 0.07, 0.51)]; // purple
  Self.FINDER_CLERK.ClusterDistance := 3;
  Self.FINDER_CLERK.Grow := 1;
  Self.FINDER_CLERK.Erode := 1;
  Self.FINDER_CLERK.MinLongSide := 10;
end;

procedure TRSGrandExchange.SetupAlignment(Mode: ERSClientMode); override;
begin
  inherited;

  case Self.Mode of
    ERSClientMode.FIXED:
      begin
        Self.Alignment.Left := [@InterfaceArea.X1];
        Self.Alignment.Right := [@InterfaceArea.X2];
        Self.Alignment.Top := [@InterfaceArea.Y1];
        Self.Alignment.Bottom := [@InterfaceArea.Y2];
        Self.Alignment.Center.MaxWidth := 484;
        Self.Alignment.Center.MaxHeight := 304;
      end;

    ERSClientMode.RESIZABLE_CLASSIC, ERSClientMode.RESIZABLE_MODERN:
      begin
        Self.Alignment.Left := [@InterfaceArea.X1];
        Self.Alignment.Right := [@InterfaceArea.X2];
        Self.Alignment.Top := [@InterfaceArea.Y1, -1];
        Self.Alignment.Bottom := [@InterfaceArea.Y2];
        Self.Alignment.Center.MaxWidth := 484;
        Self.Alignment.Center.MaxHeight := 304;
      end;
  end;
end;

var
  GrandExchange: TRSGrandExchange;

(*
Bank.Open
~~~~~~~~~
.. pascal:: function TRSBank.Open(Location: ERSBankLocation): Boolean; override;

Overrides **Bank.Open** to support opening the grand exchange.
*)
function TRSBank.Open(Location: ERSBankLocation): Boolean; override;
begin
  if (Location = ERSBankLocation.GRAND_EXCHANGE) then
    Result := GrandExchange.OpenBank()
  else
    Result := inherited();
end;

procedure TRSClient.ClientModeChanged; override;
begin
  inherited;

  GrandExchange.SetupAlignment(Self.Mode);
end;

procedure TSRL.Setup; override;
begin
  inherited;

  GrandExchange.Setup();
end;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  GrandExchange.Draw(Bitmap);
end;
